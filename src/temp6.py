import requests
import time
import hmac
import hashlib
import json
from urllib.parse import urlencode

class LBankAPIError(Exception):
    """Custom exception for LBank API errors."""
    def __init__(self, status_code, error_response):
        self.status_code = status_code
        self.error_response = error_response
        try:
            self.message = f"LBank API Error ({status_code}): {error_response.get('error_code', '')} - {error_response.get('msg', str(error_response))}"
        except AttributeError:
            self.message = f"LBank API Error ({status_code}): {str(error_response)}"
        super().__init__(self.message)

class LBankSpotAPI:
    """
    A Python client for interacting with the LBank Spot API (v2).
    Note: LBank's API documentation can sometimes be inconsistent between V1 and V2,
    or across different documents. This client aims to use V2 conventions where possible,
    primarily focusing on HmacSHA256 authentication for private endpoints.
    """
    # Prioritizing v2 endpoint, older docs might show lbkex.com
    BASE_URL_V2 = "https://api.lbank.info/v2"
    # V1 Base URL, used as a fallback for certain public endpoints if V2 is not clearly defined
    BASE_URL_V1 = "https://api.lbkex.com/v1"


    def __init__(self, api_key=None, secret_key=None):
        self.api_key = api_key
        self.secret_key = secret_key
        self.session = requests.Session()

    def _get_timestamp_ms(self):
        """Returns the current timestamp in milliseconds."""
        return int(time.time() * 1000)

    def _sign_request_params(self, params):
        """
        Signs the request parameters using HmacSHA256.
        LBank's V1 documentation mentioned MD5 after sorting, but HmacSHA256 is more standard
        and mentioned for Spot clients in some LBank connector examples.
        The exact string-to-sign format can vary between exchanges.
        A common method is to sort parameters alphabetically, create a query string,
        and then sign that.
        """
        if not self.secret_key:
            raise ValueError("Secret Key must be provided for signed requests.")

        sorted_params = sorted(params.items())
        query_string = urlencode(sorted_params)
        
        # LBank's V1 documentation specifies MD5 of the secret_key for signing.
        # However, HmacSHA256 is more common and secure.
        # Given the Node.js connector mentioning HmacSHA256 for Spot, we will use that.
        # If issues arise, this is a key area to double-check against LBank's *exact* current spec for V2 Spot API.
        # The official lbank-official-api-docs on GitHub for V1 mentioned using an MD5 hash of the secret key itself as the key for the HMAC-MD5.
        # Let's try a standard HmacSHA256 approach first.
        
        # The parameters for the signature are typically the query_string (params alphabetically sorted and urlencoded)
        # and the secret key.
        # For LBank V1, the signature was generated by MD5 hashing the query string appended with "&secret_key=YOUR_SECRET_KEY_MD5_HASH".
        # For V2 with HmacSHA256, it's likely more standard: HMAC-SHA256(query_string, secret_key).
        # The final signature is usually sent as a parameter named 'sign'.

        # Let's re-verify based on V1 docs method which is parameter string + MD5(secret_key)
        # V1 signing:
        # 1. Sort params alphabetically (excluding 'sign')
        # 2. Create query string: k1=v1&k2=v2...
        # 3. Append MD5 of secret_key: query_string + "&secret_key=" + hashlib.md5(self.secret_key.encode('utf-8')).hexdigest().upper()
        # 4. MD5 hash the result of step 3. This becomes the 'sign' parameter.
        # This is for V1 with MD5.
        
        # For V2 with HmacSHA256 (more probable for modern spot APIs):
        # The exact construction of the message to be signed must be confirmed from LBank's V2 documentation.
        # A common pattern is:
        #
        # For POST requests (application/x-www-form-urlencoded):
        # The parameters (excluding 'sign' itself) are sorted alphabetically.
        # A query string is formed: param1=value1&param2=value2...
        # This query string is then signed using HmacSHA256 with the secret_key.
        # The signature is then typically converted to hexdigest and often to uppercase.
        
        # Based on `lbank-official-api-docs` (master branch, API-For-Spot-EN/Getting Started.md):
        # "User submitted parameters must be signed in addition to sign.
        # The string to be signed is ordered according to the parameter name
        # (first compares the first letter of all parameter names, in alphabet order...)."
        # "MD5 algorithm is used to perform a signature operation on the final string to be signed...
        # In the MD5 calculation result, letters are all capitalized."
        # This describes MD5, not HmacSHA256.
        #
        # However, the Node.js connector `Spot` client clearly states `signMethod: 'HmacSHA256'`.
        # Let's assume HmacSHA256 is used for V2 and the message is the sorted query string.
        
        signature = hmac.new(
            self.secret_key.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest().upper() # Often, exchanges expect uppercase hex signatures
        
        params['sign'] = signature
        # Some APIs also require the signature_method parameter
        # params['signature_method'] = 'HmacSHA256' # Or 'RSA' for some of their other systems.
                                                # For V2 Spot, HmacSHA256 is more likely.
        return params

    def _request(self, method, endpoint_v1=None, endpoint_v2=None, params=None, data=None, signed=False, use_v1_base_for_public=False):
        """Handles the actual HTTP request."""
        if params is None:
            params = {}
        if data is None: # For POST application/x-www-form-urlencoded
            data = {}

        base_url = self.BASE_URL_V2
        endpoint = endpoint_v2

        if use_v1_base_for_public and not signed: # Use V1 base and endpoint for some public calls if specified
            base_url = self.BASE_URL_V1
            endpoint = endpoint_v1
        elif not endpoint_v2 and endpoint_v1: # Fallback to V1 endpoint if V2 not provided
             base_url = self.BASE_URL_V1
             endpoint = endpoint_v1
        elif not endpoint:
            raise ValueError("Endpoint must be provided.")

        url = f"{base_url}{endpoint}"
        headers = {}

        if signed:
            if not self.api_key:
                raise ValueError("API Key must be provided for signed requests.")
            
            # Common parameters for signed requests
            # For LBank V2, `echostr` and `timestamp` might be needed alongside `api_key` before signing
            # The exact set of parameters to include in the signature base string is critical.
            # Assuming all passed `params` or `data` (for POST) are part of the signature.
            
            # Prepare payload for signing (either GET params or POST data)
            payload_to_sign = {}
            if method.upper() == "GET":
                payload_to_sign.update(params)
            elif method.upper() == "POST":
                 payload_to_sign.update(data) # For application/x-www-form-urlencoded

            payload_to_sign['api_key'] = self.api_key
            
            # Add timestamp (required by many exchanges for signed requests to prevent replay attacks)
            # LBank V2 API docs for some private endpoints (e.g. /v2/subscribe/get_key.do) show 'timestamp' and 'echostr'.
            # For actual trading/info endpoints, let's assume timestamp is needed.
            current_timestamp = str(self._get_timestamp_ms())
            payload_to_sign['timestamp'] = current_timestamp
            
            # Echostr might be required for some endpoints, especially for authentication/websocket setup.
            # For regular trading, it's less common but check specific LBank V2 docs.
            # If not needed for all, it might be added specifically where required.
            # For now, let's assume it's NOT universally required for all signed Spot endpoints unless specified.
            # payload_to_sign['echostr'] = ''.join(random.choices(string.ascii_letters + string.digits, k=32))

            # Sign the combined parameters
            signed_payload = self._sign_request_params(payload_to_sign)

            if method.upper() == "GET":
                params = signed_payload
            elif method.upper() == "POST":
                data = signed_payload # Now data includes api_key, timestamp, and sign
                headers['Content-Type'] = 'application/x-www-form-urlencoded'


        # print(f"Request URL: {url}")
        # print(f"Method: {method}")
        # if params: print(f"Params: {params}")
        # if data: print(f"Data: {data}")
        # if headers: print(f"Headers: {headers}")

        try:
            if method.upper() == "GET":
                response = self.session.get(url, params=params, headers=headers, timeout=10)
            elif method.upper() == "POST":
                response = self.session.post(url, data=data, headers=headers, timeout=10) # data for x-www-form-urlencoded
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")

            # print(f"Response Status: {response.status_code}")
            # print(f"Response Text: {response.text}")
            
            response_json = response.json()

            # LBank specific error checking - this can vary.
            # Often, a 'result' field is 'true' for success, or 'error_code' is 0.
            if response.status_code >= 400: # HTTP error
                 raise LBankAPIError(response.status_code, response_json)
            
            # LBank specific success check (example structure, adjust based on actual responses)
            # V1 responses often had a "result": "true" or "false"
            # V2 might have "code": 0 for success or specific error codes.
            # Let's assume a "result" field for now from V1, or an error_code field.
            if 'result' in response_json and str(response_json.get('result')).lower() == 'false':
                raise LBankAPIError(response.status_code, response_json)
            if 'error_code' in response_json and response_json['error_code'] != 0: # Common pattern
                # Check LBank API docs for their specific success/error code indicators for V2
                # A common error code for success is 0.
                # The lbank-official-api-docs mentions error codes (e.g. 10003 = signature error)
                raise LBankAPIError(response.status_code, response_json)
            if 'code' in response_json and response_json['code'] != 0 and response_json['code'] != 200: # another common pattern
                 raise LBankAPIError(response.status_code, response_json)


            return response_json

        except requests.exceptions.RequestException as e:
            raise LBankAPIError(status_code=None, error_response={'error_code': 'NETWORK_ERROR', 'msg': str(e)})
        except ValueError as e: # Includes JSONDecodeError
             raise LBankAPIError(status_code=response.status_code if 'response' in locals() else None, 
                                 error_response={'error_code': 'INVALID_JSON_RESPONSE', 'msg': response.text if 'response' in locals() else str(e)})

    # --- Public Market Data Methods ---
    def get_ticker_information(self, symbol: str):
        """
        Fetches ticker information for a specific symbol.
        LBank symbol format is typically 'eth_usdt'.
        Uses V1 endpoint as it's clearly documented. V2 might be similar.
        e.g. /v1/ticker.do?symbol=eth_usdt
        A V2 equivalent might be /v2/ticker.do or /v2/market/ticker
        """
        params = {'symbol': symbol.lower()}
        # The Node.js connector implies a method like `bookTicker`, which might be /v2/accuracy.do or similar.
        # For simplicity and based on clear V1 docs:
        return self._request("GET", endpoint_v1="/ticker.do", endpoint_v2="/ticker.do", params=params, use_v1_base_for_public=True)
        # If a V2 specific public ticker is confirmed:
        # return self._request("GET", endpoint_v2=f"/ticker.do", params=params)


    # --- Authenticated Account/Trading Methods ---
    def get_account_balance(self):
        """
        Retrieves account balance information.
        Endpoint based on V1: /v1/user_info.do. A V2 equivalent would be /v2/user_info.do or /v2/account.do etc.
        Requires API key and signature.
        """
        # For V2, the endpoint might be /v2/account/info or similar.
        # Let's assume /v2/user_info.do based on V1 pattern.
        # Parameters required for signing (api_key, timestamp) will be added by _request method.
        # The V1 user_info.do POST request just took api_key and sign.
        # For V2 with HmacSHA256, and GET request, timestamp will be auto-added.
        return self._request("POST", endpoint_v1="/user_info.do", endpoint_v2="/user_info.do", signed=True, data={})


    def create_spot_order(self, symbol: str, order_type: str, price: float, amount: float, trade_type: str = None):
        """
        Places a new spot order.
        LBank V1 endpoint: /create_order.do (POST)
        Parameters: symbol, type ('buy' or 'sell'), price, amount.
        For V2, it's likely /v2/create_order.do or /v2/trade/orders.do

        Args:
            symbol (str): Trading pair, e.g., "eth_usdt".
            order_type (str): "buy" or "sell". (This aligns with LBank's `type` param)
            price (float): Price for the order (for limit orders).
            amount (float): Quantity to buy/sell.
            trade_type (str, optional): Some exchanges differentiate order types like 'limit', 'market'.
                                      LBank's V1 /create_order seems to imply limit orders by requiring price.
                                      If LBank V2 has specific market order types, this would need adjustment.
                                      For now, we assume this creates a limit order.
        """
        if order_type.lower() not in ['buy', 'sell']:
            raise ValueError("order_type must be 'buy' or 'sell'")

        data = {
            'symbol': symbol.lower(),
            'type': order_type.lower(),
            'price': str(price),
            'amount': str(amount),
            # 'custom_id': 'your_custom_order_id' # Optional: LBank might support a custom order ID
        }
        # This endpoint is POST and requires Content-Type: application/x-www-form-urlencoded
        return self._request("POST", endpoint_v1="/create_order.do", endpoint_v2="/create_order.do", data=data, signed=True)


    def create_buy_order(self, symbol: str, price: float, amount: float):
        """Helper function to create a buy limit order."""
        return self.create_spot_order(symbol=symbol, order_type="buy", price=price, amount=amount)

    def create_sell_order(self, symbol: str, price: float, amount: float):
        """Helper function to create a sell limit order."""
        return self.create_spot_order(symbol=symbol, order_type="sell", price=price, amount=amount)

    def get_order_info(self, symbol: str, order_id: str):
        """
        Retrieves information about a specific order.
        V1 endpoint: /orders_info.do (POST)
        Parameters: symbol, order_id
        V2 likely: /v2/orders_info.do or /v2/trade/orders/{order_id} (GET or POST)
        """
        data = {
            'symbol': symbol.lower(),
            'order_id': order_id
        }
        return self._request("POST", endpoint_v1="/orders_info.do", endpoint_v2="/orders_info.do", data=data, signed=True)

    def cancel_spot_order(self, symbol: str, order_id: str):
        """
        Cancels an open spot order.
        V1 endpoint: /cancel_order.do (POST)
        Parameters: symbol, order_id
        V2 likely: /v2/cancel_order.do or /v2/trade/orders/{order_id}/cancel
        """
        data = {
            'symbol': symbol.lower(),
            'order_id': order_id
        }
        return self._request("POST", endpoint_v1="/cancel_order.do", endpoint_v2="/cancel_order.do", data=data, signed=True)

# --- Wrapper classes as requested ---

class LBankMarket:
    def __init__(self, client: LBankSpotAPI):
        self.client = client

    def get_price(self, pair: str):
        """
        Gets the latest price information for a given pair.
        Args:
            pair (str): The trading pair, e.g., "ETH_USDT".
        Returns:
            dict: Ticker information from LBank.
        """
        if not isinstance(pair, str) or '_' not in pair:
            raise ValueError("Pair must be a string in format like 'ETH_USDT'")
        
        symbol = pair.lower() # LBank uses lowercase symbols with underscore
        try:
            ticker_data = self.client.get_ticker_information(symbol)
            # The response structure from /v1/ticker.do for a single symbol:
            # {
            #   "symbol": "eth_usdt",
            #   "ticker": {
            #     "high": "2000.0",
            #     "vol": "10000.0",
            #     "low": "1800.0",
            #     "change": "1.5", // Percentage change
            #     "turnover": "19000000.0",
            #     "latest": "1950.0" // Last price
            #   },
            #   "timestamp": 1678886400000
            # }
            # For V2, the structure might be different, ensure parsing is correct.
            # If the response is a list (e.g. if 'all' was passed or V2 structure changes)
            if isinstance(ticker_data, list):
                for item in ticker_data:
                    if item.get('symbol') == symbol:
                        return item
                raise LBankAPIError(None, {"error_code": "DATA_NOT_FOUND", "msg": f"Ticker for {symbol} not found in list response."})
            elif isinstance(ticker_data, dict) and 'ticker' in ticker_data and 'latest' in ticker_data['ticker']:
                 return {"symbol": ticker_data.get("symbol"), "price": float(ticker_data["ticker"]["latest"]), "full_data": ticker_data}
            else:
                # Fallback for potentially different V2 structure, return raw if specific fields not found
                # Or raise error if structure is unexpected
                # print(f"Unexpected ticker data structure for {symbol}: {ticker_data}")
                # For now, return it and let user inspect if structure deviates
                return {"symbol": symbol, "price": None, "full_data": ticker_data, "notice": "Could not parse latest price directly."}


        except LBankAPIError as e:
            # print(f"Error fetching price for {pair}: {e}")
            raise  # Re-raise the error for the caller to handle
        except Exception as e:
            # print(f"An unexpected error occurred when fetching price for {pair}: {e}")
            raise LBankAPIError(None, {"error_code": "CLIENT_ERROR", "msg": str(e)})


class LBankTrading:
    def __init__(self, client: LBankSpotAPI):
        self.client = client

    def place_order(self, pair: str, side: str, price: float, quantity: float, order_category: str = "limit"):
        """
        Places a trade order.

        Args:
            pair (str): The trading pair, e.g., "ETH_USDT".
            side (str): "long" for a buy order, "short" for a sell order (spot context).
            price (float): The price at which to place the limit order.
            quantity (float): The amount of the base currency to trade.
            order_category (str): Type of order, defaults to "limit". LBank's basic /create_order
                               is a limit order. Market orders would need different handling/endpoint if supported.
        Returns:
            dict: The response from LBank, typically containing the order_id.
        """
        if not isinstance(pair, str) or '_' not in pair:
            raise ValueError("Pair must be a string in format like 'ETH_USDT'")
        
        symbol = pair.lower()
        
        if side.lower() == "long":
            order_type = "buy"
        elif side.lower() == "short": # Spot sell
            order_type = "sell"
        else:
            raise ValueError("Side must be 'long' or 'short'.")

        if order_category.lower() != "limit":
            # LBank V1 /create_order.do is a limit order.
            # If LBank V2 has explicit market orders via a different endpoint or parameter,
            # this logic would need to be expanded.
            raise NotImplementedError(f"Order category '{order_category}' is not currently supported by this basic implementation. Only 'limit' is.")

        try:
            # print(f"Placing {order_type} order for {quantity} {symbol.split('_')[0]} at {price} {symbol.split('_')[1]}")
            response = self.client.create_spot_order(symbol=symbol, order_type=order_type, price=price, amount=quantity)
            # Expected V1 response: {"result":"true", "order_id":"..."}
            # V2 might be: {"code": 0, "data": {"order_id": "...", ...}, "msg": "Success"}
            return response
        except LBankAPIError as e:
            # print(f"Error placing order for {pair}: {e}")
            raise
        except Exception as e:
            # print(f"An unexpected error occurred when placing order for {pair}: {e}")
            raise LBankAPIError(None, {"error_code": "CLIENT_ERROR", "msg": str(e)})

    def get_order_details(self, pair: str, order_id: str):
        """
        Retrieves the details of a specific order.
        Args:
            pair (str): The trading pair, e.g., "ETH_USDT".
            order_id (str): The ID of the order to retrieve.
        Returns:
            dict: Order details from LBank.
        """
        symbol = pair.lower()
        try:
            return self.client.get_order_info(symbol=symbol, order_id=order_id)
        except LBankAPIError as e:
            raise
        except Exception as e:
            raise LBankAPIError(None, {"error_code": "CLIENT_ERROR", "msg": str(e)})

    def cancel_order(self, pair: str, order_id: str):
        """
        Cancels an open order.
        Args:
            pair (str): The trading pair, e.g., "ETH_USDT".
            order_id (str): The ID of the order to cancel.
        Returns:
            dict: Confirmation of cancellation from LBank.
        """
        symbol = pair.lower()
        try:
            return self.client.cancel_spot_order(symbol=symbol, order_id=order_id)
        except LBankAPIError as e:
            raise
        except Exception as e:
            raise LBankAPIError(None, {"error_code": "CLIENT_ERROR", "msg": str(e)})


class LBankExchangeAPI:
    """
    Main API facade that brings together Market Data and Trading functionalities.
    """
    def __init__(self, api_key: str = None, secret_key: str = None):
        """
        Initializes the LBank Exchange API client.

        Args:
            api_key (str, optional): Your LBank API key. Required for trading and private endpoints.
            secret_key (str, optional): Your LBank API secret. Required for trading and private endpoints.
        """
        self._client = LBankSpotAPI(api_key=api_key, secret_key=secret_key)
        self.market = LBankMarket(self._client)
        self.trading = LBankTrading(self._client)

    def get_eth_usdt_price(self):
        """Convenience method to get ETH_USDT price."""
        return self.market.get_price("ETH_USDT")

    # You can add more convenience methods here

if __name__ == '__main__':
    # --- IMPORTANT: Before running ---
    # 1. Get your API Key and Secret Key from LBank.
    # 2. For security, set them as environment variables or use a secure config method.
    #    DO NOT hardcode them here for production use.
    # Example:
    # API_KEY = os.environ.get("LBANK_API_KEY")
    # SECRET_KEY = os.environ.get("LBANK_SECRET_KEY")
    
    API_KEY = "YOUR_API_KEY"  # Replace with your actual API key or load from env
    SECRET_KEY = "YOUR_SECRET_KEY" # Replace with your actual secret key or load from env

    # --- Public API Endpoint Example (No API Key needed for this specific call via get_ticker_information) ---
    print("--- Testing Market Data (Public Ticker) ---")
    public_client = LBankSpotAPI() # No keys needed for public ticker
    market_ops_public = LBankMarket(public_client)
    try:
        eth_price_info = market_ops_public.get_price("ETH_USDT")
        print(f"ETH_USDT Price Info: {eth_price_info}")
        if eth_price_info and eth_price_info.get('price') is not None:
            print(f"Current ETH_USDT Price: {eth_price_info['price']}")
        else:
            print("Could not retrieve ETH_USDT price.")
            
        btc_price_info = market_ops_public.get_price("BTC_USDT")
        print(f"BTC_USDT Price Info: {btc_price_info}")

    except LBankAPIError as e:
        print(f"API Error fetching public data: {e}")
    except Exception as e:
        print(f"Generic error: {e}")
    print("-" * 30)


    # --- Authenticated API Endpoint Examples (Requires API Key and Secret Key) ---
    if API_KEY == "YOUR_API_KEY" or SECRET_KEY == "YOUR_SECRET_KEY":
        print("\nWARNING: API_KEY and SECRET_KEY are not set. Skipping authenticated tests.")
        print("Please replace 'YOUR_API_KEY' and 'YOUR_SECRET_KEY' with your actual LBank credentials to test trading.")
    else:
        lbank_api = LBankExchangeAPI(api_key=API_KEY, secret_key=SECRET_KEY)

        print("\n--- Testing Authenticated Endpoints ---")
        
        # Example: Get ETH_USDT Price using the main facade
        try:
            print("\nFetching ETH_USDT price via facade...")
            eth_usdt_facade_price = lbank_api.get_eth_usdt_price()
            print(f"Facade ETH_USDT Price Info: {eth_usdt_facade_price}")
        except LBankAPIError as e:
            print(f"API Error (Facade ETH_USDT Price): {e}")

        # Example: Get Account Balance
        try:
            print("\nFetching account balance...")
            balance = lbank_api._client.get_account_balance() # Accessing underlying client method
            print(f"Account Balance: {balance}")
        except LBankAPIError as e:
            print(f"API Error (Account Balance): {e}")

        # Example: Place a Test Order (Use with extreme caution and on a test pair or with very small amounts if real)
        # Ensure the pair 'test_usdt' exists and you have funds, or use a common pair like 'eth_usdt'
        # For actual testing, you might want to use a very low-value coin pair if available,
        # or ensure your price is far from the market to avoid immediate execution if just testing API call.
        test_pair = "eth_usdt" # Use a valid pair
        test_buy_price = 1000.00 # Intentionally low price for ETH to avoid accidental fill in testing (adjust!)
        test_buy_amount = 0.005  # Small amount of ETH

        # test_sell_price = 5000.00 # Intentionally high price for ETH
        # test_sell_amount = 0.001

        order_id_to_check = None

        try:
            print(f"\nAttempting to place a test BUY order for {test_pair}...")
            # Ensure you have sufficient USDT quote currency to buy
            buy_order_response = lbank_api.trading.place_order(
                pair=test_pair,
                side="long", # "buy"
                price=test_buy_price,
                quantity=test_buy_amount
            )
            print(f"Buy Order Response: {buy_order_response}")
            if buy_order_response and (buy_order_response.get('result') == 'true' or buy_order_response.get('code') == 0):
                 order_id_to_check = buy_order_response.get('order_id') or (buy_order_response.get('data', {}).get('order_id'))
                 print(f"Buy order placed successfully. Order ID: {order_id_to_check}")
            else:
                print("Buy order placement failed or response format unexpected.")

        except LBankAPIError as e:
            print(f"API Error (Placing Buy Order): {e}")
        except Exception as e:
            print(f"Generic error placing buy order: {e}")


        # Example: Get Order Info (if an order was placed)
        if order_id_to_check:
            try:
                print(f"\nFetching info for order ID: {order_id_to_check}...")
                order_info = lbank_api.trading.get_order_details(pair=test_pair, order_id=order_id_to_check)
                print(f"Order Info: {order_info}")
            except LBankAPIError as e:
                print(f"API Error (Get Order Info): {e}")

            # Example: Cancel Order (if an order was placed and is still open)
            try:
                print(f"\nAttempting to cancel order ID: {order_id_to_check}...")
                cancel_response = lbank_api.trading.cancel_order(pair=test_pair, order_id=order_id_to_check)
                print(f"Cancel Order Response: {cancel_response}")
            except LBankAPIError as e:
                print(f"API Error (Cancel Order): {e}")
        else:
            print("\nSkipping Get/Cancel Order Info as no order_id was obtained from placement.")